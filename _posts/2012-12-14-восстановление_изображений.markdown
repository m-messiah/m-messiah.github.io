---
layout: post
status: publish
published: true
title: Восстановление изображений
author: M_Messiah
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://brainstorage.me/M_Messiah
excerpt: "Восстановление изображений и фильтры"
date: 2012-12-14 14:09:14.000000000 +06:00
categories: Обработка_изображений
tags: []
comments: []
---

**Восстановление**

f - нормальное изображение, ![hat_f](/img/hat_f.svg) - восстановленное.

Есть много способов восстановить.



1 способ: 

![norm_minimize](/img/norm_minimize.svg)

Предположим, g(x)=f*g+n

## Вероятностная модель искажения изображения ##
Случайные величины - яркости пикселя. * (256-ти уровневая шкала) *

* **Случайное поле** * - случайная функция нескольких переменных.

1.	Исходное изображение -&nbsp;**случайное поле**.
2.	n - случайное поле, с ограничением:
	1.	M(n)=0 (матожидание)
3.	f и n - не коррелируют между собой, то есть M(fn)=0

f -> F

Известна формула: ![integral square](/img/integral_square.svg)

Искажение: g=h*f + n

Нужно найти фильтр &phi;, который поможет уменьшить искажение.

Чтобы задачу можно было решить в каком-то конечном виде, определим класс восстанавливающих фильтров. Пусть класс будет такой же - инвариантных от сдвига.

Будем искать ![varphi*g](/img/varphi_g.svg)

То есть, найти такую &phi;, что ![varphi->min](/img/varphi_min.svg)

Эту задачу решает **фильтр Винера.**

Всё делаем в частотной области.

На входе имеем:

G=FH+N (это уже комплекснозначные спектры, тут нормальное обычное произведение комплексных чисел)

Предположения:

1.	&int;N =0
2.	&int;FN =0

Тогда ищем ![Viner](/img/trans_func_Viner.svg) - передаточная функция Винера

![Viner1](/img/viner1.svg)

Введем скалярную вариацию R: &Phi;=&Phi;0+&tau; R

Подставим &Phi;0 в нашу формулу и сделаем её зависимой от скалярного аргумента : ![Viner2](/img/viner2.svg)

![Viner filter](/img/viner_filter.svg) - фильтр Винера.

Ищем такое &Phi;0 что ![Viner filter](/img/viner_filter.svg) &forall;R

Задача выпуклая и всё клёво получается.

![Viner Task](/img/viner_task.svg)

Дифференцируем интеграл:

![Viner Task Diff](/img/viner_task1.svg)

И подставляем получившееся произведение и приравниваем:

![Viner Task 2](/img/viner_task2.svg)

![Viner Task 3](/img/viner_task3.svg)

GF=F&sup2;H+NF, NF - можно опустить, так как они для любого R должны давать ноль. Это только когда они сами ноль.

![Viner Task 4](/img/viner_task4.svg)

![Viner Task 5](/img/viner_task5.svg), где W - скобка при R*

В итоге достаточно найти, когда W=0

&Phi;0(F&sup2;H&sup2;+N&sup2;)=F&sup2;H*


![Viner Filter 1](/img/viner_filter1.svg), но лучше фильтр Винера записать, как ![Viner Filter 2](/img/viner_filter2.svg)

Но на практике это неудобно вааащпе(((( Так как ни шума, ни мощности сигнала не дано. Так что проще заменить отношение сигнала к шуму константой. Хотя удобнее сделать не константу, а что-нибудь поточнее - K(u,v)

Вопрос: Где взять H - ядро искажающего оператора?

На практике есть несколько рекомендаций:

1.	Оценка H по фрагмент{у/ам}:
	G=HF, H=G/F (из участка изображения) Недостатки: искать незашумленный участок, локальность и вообще плохо(( Если ничего нет, тогда можно.
2.	На основе экспериментов
3.	На основе матмоделирования. (годится для построения фильтра для смаза).

Если экспозиция не мгновенная, а в промежутке [0,T] - стопудово смаз будет. Пусть аппарат проходит за это время плоский путь (x(t),y(t))

Если смаз параллельный:

![Smaz](/img/model_smaz.svg) - модель смаза.

Что здесь H? Цель: G~HF

Строим обратное преобразование Фурье:

![Reverse Furie](/img/reverse_furie.svg)

G=FH+N

Если N- мало, N-простое, то можно F=G/H

Если H где-то обращается в 0 или другие проблемы, то ![Viner Task 6](/img/viner_task6.svg)

