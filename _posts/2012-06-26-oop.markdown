---
layout: post
status: publish
published: true
title: ООП
author: ––=Messiλh=––
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://m.muzafarov.vk.com
excerpt: "<h1>ООП в Perl<&#47;h1>\r\n"
wordpress_id: 100
wordpress_url: http://messiah.ks8.ru/wordpress/?p=100
date: 2012-06-26 22:37:12.000000000 +06:00
categories:
- Perl
tags: []
comments: []
---
<h1>ООП в Perl<&#47;h1>
<a id="more"></a><a id="more-100"></a>
<h1><&#47;h1>
<h1>Сделаем класс треугольник.<&#47;h1>
<h2>1. Triangle.pm<&#47;h2>
<pre class="brush: perl; gutter: true">package Triangle;
 use strict;
 use overload (&#039;==&#039; => \&amp;equal,
 &#039;""&#039; => \&amp;tostr);
 sub new{
 my $cl=shift; $cl = ref($cl)||$cl;
 my @val= sort {$a <=> $b} @_;
 print \@val,"\n";
 return bless \@val,$cl;
 }
 sub P{
 my $self=shift;
 return $self->[0]
 +
 $self->[1]
 +
 $self->[2];}
 sub equal{
 my $self = shift;
 my $other = shift;
 return 0+(
 $self->[0] == $other->[0]
 &amp;&amp; $self->[1] == $other->[1]
 &amp;&amp; $self->[2] == $other->[2]);
 }
 sub tostr{
 my $self = shift;
 return ("<".$self->[0].", ".$self->[1].", ".$self->[2].">");
 }
 1;<&#47;pre>
&nbsp;
<h2>2. STriangle.pm<&#47;h2>
<pre class="brush: perl; gutter: true">package STriangle;
 use strict;
 require Triangle;
 our @ISA=qw(Triangle);
 sub S{
 my $me=shift;
 my $p2=0.5*$me->P();
 return sqrt($p2*($p2-$me->[0])*($p2-$me->[1])*($p2-$me->[2]));
 }
 1;<&#47;pre>
&nbsp;
<h2>3. main.pl<&#47;h2>
<pre class="brush: perl; gutter: true">#!&#47;usr&#47;bin&#47;perl -w
 $\=$&#47;;
 use STriangle;
 $tr_o = new STriangle(5,4,3);
 print "$tr_o";
 print "@$tr_o\n";
 print "p= ",$tr_o->P()," S= ",$tr_o->S(),"\n";
 $tr_l = new STriangle(4,3,5);
 print $tr_o->equal($tr_l);
 print $tr_o==$tr_l;
 print $tr_o->tostr();<&#47;pre>
<h1>Results<&#47;h1>
ARRAY(0x8d4ec80)

<3, 4, 5>
3 4 5

p= 12 S= 6

ARRAY(0x8d594f0)

1
1
<3, 4, 5>
<h1>Связывание<&#47;h1>
Класс Скаляр
Переопределение интересных встроенных методов.
<h2>Простейший пример<&#47;h2>
<h3>MyScalar.pm<&#47;h3>
<pre class="brush: perl; gutter: true">package MyScalar;
 my $cnt = 0;
 sub TIESCALAR {
 my $me;
 return bless \$me, $_[0]; }
sub FETCH { ${$_[0]} }
sub STORE {
 my ($me, $v) = @_;
 ++$cnt if $v<0;
 $$me=$v;
 }
 sub cnt {return $cnt;}
 1;<&#47;pre>
<h2>Основная программа<&#47;h2>
<pre class="brush: perl; gutter: true">#!&#47;usr&#47;bin&#47;perl -w
 use MyScalar;
 $a_a = tie $a, &#039;MyScalar&#039;;
 for (1, 12.5, -13, 81e-1, -1_0_0) {$a=$_;}
 print "&#039;-&#039;-->a = ",$a_a->cnt(), "\n";<&#47;pre>
<h2>Модифицированный<&#47;h2>
<h3>MyScalar1.pm<&#47;h3>
<pre class="brush: perl; gutter: true">package MyScalar1;
 sub TIESCALAR {
 my %me={ val => undef, cnt => 0};
 print &#039;TIESCALAR:&#039;,\$me,"\n";
 return bless \%me, $_[0]; }
sub FETCH { $_[0]->{val} }
sub STORE {
 my ($me, $v) = @_;
 ++($me->{cnt}) if $v<0;
 $me->{val}=$v;
 }
 sub cnt {return $_[0]->{cnt};}
 1;<&#47;pre>
&nbsp;
<h3>Тест для мода<&#47;h3>
<pre class="brush: perl; gutter: true">#!&#47;usr&#47;bin&#47;perl -w
 use MyScalar1;
 $a_a = tie $a, &#039;MyScalar1&#039;;
 $b_b = tie $b, &#039;MyScalar1&#039;;
 print &#039;$a_a&#039;."$a_a\n";
 for (1, 12.5, -13, 81e-1, -1_0_0) {$a=$_; $b=-$_;}
 print "&#039;-&#039;-->a = ",$a_a->cnt(), "\n";<&#47;pre>
<h2>С помощью списка<&#47;h2>
Готовая реализация
<h3>MyScalar3.pm<&#47;h3>
<pre class="brush: perl; gutter: true">package MyScalar3;
 my %cnts ;
 use Tie::Scalar;
 @ISA = qw(Tie::StdScalar);
 sub STORE {
 my ($me, $v) = @_;
 $cnts{$me}++ if $v<0;
 $$me=$v;
 }
 sub cnt {return $cnts{$_[0]};}
 sub DESTROY{
 delete $cnts{$_[0]};}
 1;<&#47;pre>
&nbsp;
<h3>Основная программа<&#47;h3>
<pre class="brush: perl; gutter: true"> #!&#47;usr&#47;bin&#47;perl -w
 use MyScalar;
 $a_a = tie $a, &#039;MyScalar&#039;;
 $b_b = tie $b, &#039;MyScalar&#039;;
for (1, 12.5, -13, 81e-1, -1_0_0) {$a=$_; $b=-$_;}
 print "&#039;-&#039;-->a = ",$a_a->cnt(), "\n";<&#47;pre>
&nbsp;
