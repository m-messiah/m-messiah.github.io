---
layout: post
status: publish
published: true
title: Задачи
author: ––=Messiλh=––
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://m.muzafarov.vk.com
excerpt: "<h1>Задачи для практических занятий по учебному курсу \"ООП\" (3 курс)<&#47;h1>\r\n<h2>Это
  важно знать:<&#47;h2>\r\nПреподаватель практики может предложить собственную линейку
  задач для проведения практических занятий\r\nЗадачи разделены на тематические блоки.
  В пределах блока студент имеет возможность выбрать одну из предложенных задач. В
  зачет идет лишь какая-то одна из задач блока.\r\n\r\n"
wordpress_id: 47
wordpress_url: http://messiah.ks8.ru/wordpress/?p=47
date: 2012-06-26 21:33:26.000000000 +06:00
categories:
- Java
tags: []
comments: []
---
<h1>Задачи для практических занятий по учебному курсу "ООП" (3 курс)<&#47;h1>
<h2>Это важно знать:<&#47;h2>
Преподаватель практики может предложить собственную линейку задач для проведения практических занятий
Задачи разделены на тематические блоки. В пределах блока студент имеет возможность выбрать одну из предложенных задач. В зачет идет лишь какая-то одна из задач блока.

<a id="more"></a><a id="more-47"></a>
<h2>Первое знакомство с Java<&#47;h2>
Цели:
научиться создавать простейшие программы на Java, компилировать их и запускать из командной строки
познакомиться со средой Eclipse, научиться использовать ее для создания, компиляции и запуска программ
освоить базовые управляющие инструкции языка (вместо HelloWorld следует использовать более сложный пример программы, рассматриваемый на лекции).

<strong>1a. Hello World<&#47;strong>

Взять исходник программы HelloWorld из материалов лекций, научиться компилировать и запускать эту программу из командной строки и из среды Eclipse
<h2>Java и процедурный стиль<&#47;h2>
Цели:

научиться программировать на Java в процедурном стиле.
попробовать трансформировать программу с процедурного стиля в стиль ООП
начать отрабатывать Правила хорошего кода.

При использовании приемов ООП следует добиться отделения логики ввода&#47;вывода от логики обработки строки.

<strong>2a. Статистика символов.<&#47;strong>

Написать программу в процедурном стиле, которая вводит с консоли строку русского текста, после чего выводит по каждой гласной букве количество раз, которое эта буква встретилась во введённой строке.

Можно попробовать решить задачу с использованием ООП, то есть ввести абстракцию, которая будет предоставлять функциональность подсчета статистики использования символов. Например, такую:
<pre class="brush: java; gutter: true">&nbsp;
class SymStats
 {
 &#47;&#47; Создает класс для подсчета статистики использования указанных
 &#47;&#47; символов
 public SymStats(char[] charsForStats);
&#47;&#47; Вычисляет статистику использования символов в данной строке
 public void calculate(String s);
&#47;&#47; Возвращает количество вхождений указанного символа
 public int countChar(char c);
&#47;&#47; Возвращает общее число подсчитываемых символов
 public int countTotal();
&#47;&#47; Выдает подсчитанную статистику на экран
 public void writeStats();
 }<&#47;pre>
<strong>2b. Баланс скобок.<&#47;strong>

Написать программу в процедурном стиле, которая вводит с консоли строку русского текста, после чего проверяет сбалансированность скобок (анализируются скобки 4 типов: круглые, фигурные, квадратные, угловые). В случае нарушения баланса (с учетом вложенности скобок!) требуется выдать информацию о месте возникновения ошибки.

В случае использования приемов ООП решение должно оформляться, например, посредством такого интерфейса:
<pre class="brush: java; gutter: false">&nbsp;
interface StringValidator
 {
 &#47;&#47; Проверяет строку на корректность
 boolean isValid(String s);
&#47;&#47; Если последний вызов isValid обнаружил ошибку, возвращает
 &#47;&#47; позицию, в которой обнаружена ошибка
 int getErrorPos();
&#47;&#47; Если последний вызов isValid обнаружил ошибку, возвращает
 &#47;&#47; сообщение об ошибке
 String getErrorMessage();
 }<&#47;pre>
С использованием такого интерфейса можно строить сложные правила проверки строк путем простого комбинирования реализаций этого интерфейса.

Также у этой задачи есть очень симпатичная вариация для сильных студентов: написать XML-валидатор (то есть проверяет правильность расстановки тегов с учетом парности и вложенности).

<a title="Баланс скобок" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;balance">Исходник готовой задачи<&#47;a>
<h2>Классы как типы данных<&#47;h2>
Цели:
познакомиться с модульным программированием;
освоить шаблон "Неизменяемый класс";
освоить модульное тестирование и JUnit в частности.

<strong>3а. Вектор и отрезок<&#47;strong>

Реализовать неизменяемый класс Vector3D, представляющий вектор в 3-хмерном пространстве. У класса должны быть следующие методы:
<pre class="brush: java; gutter: true">&nbsp;
&#47;&#47; Получение координат
 double getX();
 double getY();
 double getZ();
&#47;&#47; Операции
 double scalar(Vector3D v); &#47;&#47; скалярное произведение векторов
 double len(); &#47;&#47; длина вектора
 Vector3D multiply(double factor); &#47;&#47; умножение на число
 Vector3D add(Vector3D v); &#47;&#47; сложение векторов
 Vector3D sub(Vector3D v); &#47;&#47; вычитание векторов<&#47;pre>
<a title="Vector3D" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;vector3d">Исходник Vector3D<&#47;a>

Класс вектора должен быть покрыт модульными тестами, сделанными на основе библиотеки JUnit.

Затем следует реализовать класс Segment, представляющий отрезок в 3-хмерном пространстве. У класса должны быть следующие методы:
<pre class="brush: java; gutter: true"> Vector3D getStart();
 Vector3D getEnd();
 double len();
 double distanceTo(Vector3D point);<&#47;pre>
При этом в реализации методов класса Segment запрещается использование методов Vector3D.getX(), Vector3D.getY(), Vector3D.getZ().

<a title="Segment" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;segment">Исходник Segment<&#47;a>

Теперь легко заметить, что класс Segment в своей работе не использует знание о размерности пространства. В резлуьтате его легко обобщить так, чтобы он работал с векторами любого пространства. Для этого нужно:

Ввести интерфейс Vector абстрактного вектора со следующими методами
<pre class="brush: java; gutter: true"> int dimension(); &#47;&#47; размерность
 double getComponent(int i); &#47;&#47; возвращает компоненту вектора
 double scalar(Vector v);
 double len();
 Vector multiply(double factor);
 Vector add(Vector v);
 Vector sub(Vector v);<&#47;pre>
&nbsp;

<a title="IVector" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;ivector">Интерфейс iVector<&#47;a>

Указать, что класс Vector3D реализует этот интерфейс. Перевести класс Segment на использование Vector вместо Vector3D. Чтобы проверить, что Segment успешно обобщился, нужно создать реализацию вектора в 2-мерном пространстве Vector2D, и добавить соответствующих модульных тестов на класс Segment.

<a title="Vector2D" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;vector2d">Исходник Vector2D<&#47;a>

<a title="Vector" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;vector">Исходник Vector<&#47;a>

<a title="TestVector" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;testvector">Исходник TestVector<&#47;a>

Наблюдение: в качестве усложнения можно рассматривать задачу переписывания этих классов на обобщенные типы (generics).
<h2>Полиморфизм, как способ расширения функциональности<&#47;h2>
Цели:
познакомиться с работой в рамках существующего каркаса приложения;
освоить полиморфизм, основанный на интерфейсах и абстрактных классах.

<strong>4а. Калькулятор<&#47;strong>

Требуется разобраться с каркасом существующего приложения (студент получает готовый набор исходников) и реализовать в рамках этого каркаса поддержку следующих типов данных: вектор, рациональное число, комплексное число.
<h2>Контейнеры<&#47;h2>
Цели:
<ul>
	<li>познакомиться с реализациями контейнерных классов;<&#47;li>
	<li>познакомиться с итераторами;<&#47;li>
	<li>познакомиться с обобщенными типами;<&#47;li>
	<li>познакомиться с с использованием исключений для сигнализации об ошибках в процессе работы программы;<&#47;li>
<&#47;ul>
<strong>5a. Стек<&#47;strong>

Требуется написать класс, реализующий структуру данных "стек". Класс должен предоставлять доступ к элементам посредством итератора и быть совместимым с циклом for по итератору.

<strong>5б. Очередь<&#47;strong>

Требуется написать класс, реализующий структуру данных "очередь". Класс должен предоставлять доступ к элементам посредством итератора и быть совместимым с циклом for по итератору.

<strong>5в. Динамический массив<&#47;strong>

Требуется написать класс, реализующий "массив переменного размера". Класс должен предоставлять доступ к элементам посредством итератора и быть совместимым с циклом for по итератору.

Наблюдение: в качестве усложнения во всех трех вариантах можно рассматривать реализацию такого класса с использованием техники обобщенных типов (Generics).
<a title="Очередь" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;queue">Очередь<&#47;a>
<h2>Файловый ввод-вывод и кодировки<&#47;h2>
Цели:
познакомиться с библиотеками ввода-вывода (файлы);
научиться писать отказоустойчивые программы (грамотное использование исключений).

<strong>6а. Конвертор кодировок<&#47;strong>

Требуется написать программу, которая получает из командной строки 4 аргумента: имя исходного файла, имя исходной кодировки, имя выходного файла, имя выходной кодировки. Программа должна выполнять копирование указанного текстового файла, выполняя трансформацию кодировки.

<a title="Конвертер кодировок" href="http:&#47;&#47;messiah.ks8.ru&#47;wordpress&#47;usu&#47;java&#47;tasks&#47;filecoder">FileCoder<&#47;a>

Наблюдение: в качестве усложнения можно реализовать автоопределение входной кодировки на основе частотного анализа файла.

<strong>6b. Текстовый файл с произвольным доступом.<&#47;strong>

Требуется написать программу, которая позволила бы читать текстовые данные из произвольной позиции текстового файла (произвольный доступ организуется через класс RandomAccessFile). Можно предполагать, что исходный файл создан в кодировке UTF-8. Соответственно, при чтении надо убедиться, что с указанной позиции файла можно прочитать строку в UTF-8 (см. свойства кодировки; она позволяет выполнить синхронизацию для продолжения декодирования).

Исходники всех задач доступны на <a href="https:&#47;&#47;github.com&#47;m-muzafarov&#47;java_course" target="_blank">GitHub<&#47;a>
