---
layout: post
status: publish
published: true
title: Модульное тестирование
author: ––=Messiλh=––
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://m.muzafarov.vk.com
excerpt: "<h1>Предпосылки<&#47;h1>\r\nВ любой большой, серьёзной программе, с большим
  количеством функциональности довольно сложно искать ошибки &laquo;в лоб&raquo;.
  Иногда, чтобы добиться того, чтобы только что написанный участок кода сработал,
  необходимо сделать довольно много действий в программе: скомпилировать и собрть
  весь проект, создать тестовую базу данных, сконфигурировать программу, создать необходимое
  окружение, выполнить цепочку других необходимых действий... А для полноценной проверки
  вновь написанного кода может потребоваться проделать эти действия несколько раз
  с небольшими вариациями. Всё это может занять в несколько раз больше времени, чем
  собственно написание кода.\r\n\r\nПоэтому опытные программисты применяют давно испытанный
  приём &laquo;Разделяй и властвуй&raquo;. Они проверяют работоспособнсть каждого
  отдельного небольшого модуля. Если все модули по отдельности работают как надо,
  то проверяется работоспсобность интеграции этих модулей друг с другом. Этот подход
  носит название модульное тестирование (Unit testing).\r\n\r\nЕстественно этот подход
  работает только в том случае, если модули, из которых состит система, максимально
  независимы друг от друга и не имеют зависимостей, препятствующих тестированию.\r\n<h1>"
wordpress_id: 38
wordpress_url: http://messiah.ks8.ru/wordpress/?p=38
date: 2012-06-26 21:01:39.000000000 +06:00
categories:
- Java
tags: []
comments: []
---
<h1>Предпосылки<&#47;h1>
В любой большой, серьёзной программе, с большим количеством функциональности довольно сложно искать ошибки &laquo;в лоб&raquo;. Иногда, чтобы добиться того, чтобы только что написанный участок кода сработал, необходимо сделать довольно много действий в программе: скомпилировать и собрть весь проект, создать тестовую базу данных, сконфигурировать программу, создать необходимое окружение, выполнить цепочку других необходимых действий... А для полноценной проверки вновь написанного кода может потребоваться проделать эти действия несколько раз с небольшими вариациями. Всё это может занять в несколько раз больше времени, чем собственно написание кода.

Поэтому опытные программисты применяют давно испытанный приём &laquo;Разделяй и властвуй&raquo;. Они проверяют работоспособнсть каждого отдельного небольшого модуля. Если все модули по отдельности работают как надо, то проверяется работоспсобность интеграции этих модулей друг с другом. Этот подход носит название модульное тестирование (Unit testing).

Естественно этот подход работает только в том случае, если модули, из которых состит система, максимально независимы друг от друга и не имеют зависимостей, препятствующих тестированию.
<h1><a id="more"></a><a id="more-38"></a>xUnit<&#47;h1>
Наименьшим модулем, который можно протестировать в ОО-языках программирования является класс. Практически для каждого серьёзного языка программирования существуют системы, облегчающие создание и запуск модульных тестов. Для языка Java это в первую очередь система JUnit. Для языка C# и других .NET-языков &mdash; NUnit. Для Delphi &mdash; DUnit. Принцип их работы практически одинаков &mdash; различия лишь в деталях.
<h1>Пример модульного теста на основе JUnit<&#47;h1>
<pre class="brush: java; gutter: true">
 package study.oop.vector;
 import junit.framework.TestCase;
&#47;&#47; Модульный тест наследуется от базового класса всех модульных тестов TestCase
 public class Vector_Test extends TestCase {
&#47;&#47; Тестами считаются все методы, названия которых начинаются с профикса test
 public void testMul() {
 &#47;&#47; тестовый случай &mdash; одна строчка &mdash; один вызов вспмогательного метода checkMul
 checkMul(0, 0, 0, 1, 0, 0, 0);
 checkMul(1, 0, 0, 1, 1, 0, 0);
 checkMul(2, 3, 4, 2, 4, 6, 8);
 checkMul(2, 3, String message = "My friends: ";
 for (int i=0; i<friendsCount; i++)
 message += friend[i] + " ";
 return message; -4, -2, -4, -6, 8);
 checkMul(0, -100, 200, -12, 0, 1200, -2400);
 ...
 }
&#47;&#47; Вспомогательный метод. Служит для того, чтобы добавлять новые тестовые случаи было легко.
 private void checkMul(double x0, double y0, double z0, double factor, double x1, double y1, double z1) {
 Vector v = new Vector(x0, y0, z0);
 assertEquals(x1, v.getX());
 assertEquals(y1, v.getY());
 assertEquals(z1, v.getZ());
 }
 }<&#47;pre>
&nbsp;

Запускать тесты можно прямо из среды разработки Eclipse. Для этого в окне Package Explorer&nbsp;нужно нажать правой кнопкой на файле с тестом и выбрать <strong>'Run As -> JUnit Test'<&#47;strong>

Для работы с JUnit необходимо добавить junit в качестве библиотеки. Это можно сделать воспользовавшись подсказкой Eclipse у строки импорта.

Либо это можно сделать вручную через меню <strong>Project - Properties - Java Build Path - Libraries - Add External JARs<&#47;strong>, выбрать файл <ПутьДоEclipse><strong><em>\plugins\org.junit*\junit.jar<&#47;em><&#47;strong>
<h1>Как правильно писать тесты<&#47;h1>
Вот самые простые правила, которыми нужно руководствоваться:
<ul>
	<li>&nbsp;Лучше путь тестов будет сильно больше, чем немного меньше.<&#47;li>
	<li>&nbsp;Тесты должны покрывать все возможные крайние случаи.<&#47;li>
	<li>&nbsp;При выполнении тестов, 100% тестируемого кода должно выполниться.<&#47;li>
	<li>&nbsp;Тесты должны быть упорядочены так, чтобы более простые для понимания тесты шли первыми.<&#47;li>
	<li>&nbsp;Тесты должны быть устроены таким образом, чтобы добавлять новые тестовые случаи было максимально просто.<&#47;li>
<&#47;ul>
Но простыми правилами всё не ограничивается &mdash; есть множество подходов к тестированию программного обеспечения. Ниже будут приведены некоторые из них с очень кратким и поверхностным описанием.

Важный вопрос при разработке модульных тестов: когда остановиться? в каком момент можно сказать, что код протестирован полностью? Однозначеного ответа на этот вопрос нет, но есть некоторое количество методик, которые позволяют определить, что комплект тестов является неполным.
<h2>Покрытие операторов<&#47;h2>
Если при прогоне всех тестов остались операторы, которые не выполнились ни разу &mdash; набор тестов не полный.

Существуют специальные системы, которые позволяют измерять сколько раз была выполнена каждая строка кода в процессе работы тестов.
<h2>Анализ условий и граничных значений<&#47;h2>
Если в тестируемой программе есть развилки (if &#47; switch &#47; ...), то в процессе выполнения тестов каждое такое условие должно хотя бы один раз сработать и хотя бы один раз не сработать.

Более того, если условие &mdash; это сложное сравнение числа с некоторым пороговым значением, то должны быть тесты проверяющие правильное срабатывание условия в пограничных ситуациях.
Для примера рассмотрим следующий код:
<pre class="brush: java; gutter: true">
 d = b * b + 4 a * b;
 if (b == 0) return 1;
 else if (b < 0) return 0;
 return 2;<&#47;pre>
&nbsp;

Для проверки граничных значений, должны быть следующие тестовые случаи:
<ul>
	<li>случай, в котором d == 0;<&#47;li>
	<li>случай, в котором d &mdash; очень маленькое положительное число;<&#47;li>
	<li>случай, в котором d &mdash; очень маленькое по модулю отрицательное число.<&#47;li>
<&#47;ul>
Если в программе есть циклы, то до в процессе выполнения тестов, каждый цикл должен хотя бы раз выполнить минимальное количество итераций, и хотя бы раз выполнить несколько итераций.

Для примера рассмотрим следующий код:
<pre class="brush: java; gutter: false">String message = "My friends: ";
 for (int i=0; i<friendsCount; i++)
 message += friend[i] + " ";
 return message;<&#47;pre>
Для полноценной проверки, нужны два тестовых случая:
<ul>
	<li>когда есть несколько друзей;<&#47;li>
	<li>когда друзей нет.<&#47;li>
<&#47;ul>
<h2>Анализ путей выполнения<&#47;h2>
Этот метод ещё более требователен к полноте тестов. Согласно ему, все возможные пути через тестируемую часть кода должны быть хотя бы раз выполнены в процессе тестирования. Рассмотрим пример кода &mdash; попиксельное рисование линии алгоритмом Брезенхама:
<pre class="brush: java; gutter: true">void drawLine(int x1, int y1, int x2, int y2)
 {
 int slope;
 int dx, dy, incE, incNE, d, x, y;
 if (x1 > x2){
 drawLine(x2, y2, x1, y1);
 return;
 }
 dx = x2 - x1;
 dy = y2 - y1;
 if (dy < 0) {
 slope = -1;
 dy = -dy;
 }
 else
 slope = 1;
 incE = 2 * dy;
 incNE = 2 * dy - 2 * dx;
 d = 2 * dy - dx;
 y = y1;
 for (x = x1; x <= x2; x++) {
 putPixel(x, y);
 if (d <= 0)
 d += incE;
 else {
 d += incNE;
 y += slope;
 }
 }
 }<&#47;pre>
Для этого алгоритма согласно методу анализа путей выполнения должны быть добавлены следующие тестовые случаи:
<ul>
	<li>x1 > x2 &amp;&amp; y1 > y2<&#47;li>
	<li>x1 > x2 &amp;&amp; y1 < y2<&#47;li>
	<li>x1 > x2 &amp;&amp; y1 == y2<&#47;li>
	<li>x1 < x2 &amp;&amp; y1 > y2<&#47;li>
	<li>x1 < x2 &amp;&amp; y1 < y2<&#47;li>
	<li>x1 < x2 &amp;&amp; y1 == y2<&#47;li>
	<li>x1 == x2 &amp;&amp; y1 > y2<&#47;li>
	<li>x1 == x2 &amp;&amp; y1 < y2<&#47;li>
	<li>x1 == x2 &amp;&amp; y1 == y2<&#47;li>
<&#47;ul>
<h1>Резюме<&#47;h1>
<ul>
	<li>&nbsp;Писать программы нужно путём декомпозиции её на независимые модули. Каждый модуль с нетривиальным поведением должен быть протестирован модульным тестом.<&#47;li>
	<li>Для поддержки концепции модульных тестов есть большое количество библиотек, почти для любого языка программирования. Это даёт возможность лишний раз не изобретать велосипед.<&#47;li>
	<li>При создании модульного теста лучше лучше переборщить с тестовыми случаями, чем недоборщить. Для того, чтобы понять, каких тестов ещё не хватает, можно использовать различные методики анализа кода: анализ покрытия операторов тестами, анализ условий, анализ граничных значений, анализ путей исполнения.<&#47;li>
<&#47;ul>
<h1>Ссылки<&#47;h1>
<ul>
	<li>http:&#47;&#47;ru.wikipedia.org&#47;wiki&#47;Юнит-тестирование<&#47;li>
	<li>http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;JUnit<&#47;li>
	<li>http:&#47;&#47;wiki.agiledev.ru&#47;doku.php?id=tdd:testing_advantages &mdash; Test Driven Development<&#47;li>
	<li>http:&#47;&#47;www.citforum.ru&#47;SE&#47;testing&#47;mod_test&#47; &mdash; модульное тестирование<&#47;li>
	<li>http:&#47;&#47;www.google.com&#47;search?q=Модульное+тестирование<&#47;li>
	<li>http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;List_of_unit_testing_frameworks &mdash; список систем модульного тестирования<&#47;li>
	<li>[http:&#47;&#47;www.ozon.ru&#47;context&#47;detail&#47;id&#47;1501671&#47; Кент Бек, Экстремальное программирование: разработка через тестирование]<&#47;li>
<&#47;ul>
