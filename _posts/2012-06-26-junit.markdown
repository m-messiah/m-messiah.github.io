---
layout: post
status: publish
published: true
title: Модульное тестирование
author: M_Messiah
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://m.muzafarov.vk.com
excerpt: "# Предпосылки #\r\nВ любой большой, серьёзной программе, с большим
  количеством функциональности довольно сложно искать ошибки &laquo;в лоб&raquo;.
  Иногда, чтобы добиться того, чтобы только что написанный участок кода сработал,
  необходимо сделать довольно много действий в программе: скомпилировать и собрть
  весь проект, создать тестовую базу данных, сконфигурировать программу, создать необходимое
  окружение, выполнить цепочку других необходимых действий... А для полноценной проверки
  вновь написанного кода может потребоваться проделать эти действия несколько раз
  с небольшими вариациями. Всё это может занять в несколько раз больше времени, чем
  собственно написание кода.\r\n\r\nПоэтому опытные программисты применяют давно испытанный
  приём &laquo;Разделяй и властвуй&raquo;. Они проверяют работоспособнсть каждого
  отдельного небольшого модуля. Если все модули по отдельности работают как надо,
  то проверяется работоспсобность интеграции этих модулей друг с другом. Этот подход
  носит название модульное тестирование (Unit testing).\r\n\r\nЕстественно этот подход
  работает только в том случае, если модули, из которых состит система, максимально
  независимы друг от друга и не имеют зависимостей, препятствующих тестированию.\r\n<h1>"
wordpress_id: 38
wordpress_url: http://messiah.ks8.ru/wordpress/?p=38
date: 2012-06-26 21:01:39.000000000 +06:00
categories:
- Java
tags: []
comments: []
---
# Предпосылки #
В любой большой, серьёзной программе, с большим количеством функциональности довольно сложно искать ошибки &laquo;в лоб&raquo;. Иногда, чтобы добиться того, чтобы только что написанный участок кода сработал, необходимо сделать довольно много действий в программе: скомпилировать и собрть весь проект, создать тестовую базу данных, сконфигурировать программу, создать необходимое окружение, выполнить цепочку других необходимых действий... А для полноценной проверки вновь написанного кода может потребоваться проделать эти действия несколько раз с небольшими вариациями. Всё это может занять в несколько раз больше времени, чем собственно написание кода.

Поэтому опытные программисты применяют давно испытанный приём &laquo;Разделяй и властвуй&raquo;. Они проверяют работоспособнсть каждого отдельного небольшого модуля. Если все модули по отдельности работают как надо, то проверяется работоспсобность интеграции этих модулей друг с другом. Этот подход носит название модульное тестирование (Unit testing).

Естественно этот подход работает только в том случае, если модули, из которых состит система, максимально независимы друг от друга и не имеют зависимостей, препятствующих тестированию.
# xUnit #
Наименьшим модулем, который можно протестировать в ОО-языках программирования является класс. Практически для каждого серьёзного языка программирования существуют системы, облегчающие создание и запуск модульных тестов. Для языка Java это в первую очередь система JUnit. Для языка C# и других .NET-языков &mdash; NUnit. Для Delphi &mdash; DUnit. Принцип их работы практически одинаков &mdash; различия лишь в деталях.
# Пример модульного теста на основе JUnit #
{% highlight java %}
package study.oop.vector;
import junit.framework.TestCase;
// Модульный тест наследуется от базового класса всех модульных тестов TestCase
public class Vector_Test extends TestCase {
// Тестами считаются все методы, названия которых начинаются с профикса test
public void testMul() {
 // тестовый случай &mdash; одна строчка &mdash; один вызов вспмогательного метода checkMul
checkMul(0, 0, 0, 1, 0, 0, 0);
checkMul(1, 0, 0, 1, 1, 0, 0);
checkMul(2, 3, 4, 2, 4, 6, 8);
checkMul(2, 3, String message = "My friends: ";
for (int i=0; i<friendsCount; i++)
message += friend[i] + " ";
return message; -4, -2, -4, -6, 8);
checkMul(0, -100, 200, -12, 0, 1200, -2400);
 ...
}
// Вспомогательный метод. Служит для того, чтобы добавлять новые тестовые случаи было легко.
private void checkMul(double x0, double y0, double z0, double factor, double x1, double y1, double z1) {
Vector v = new Vector(x0, y0, z0);
assertEquals(x1, v.getX());
assertEquals(y1, v.getY());
assertEquals(z1, v.getZ());
}
}{% endhighlight %}
&nbsp;

Запускать тесты можно прямо из среды разработки Eclipse. Для этого в окне Package Explorer&nbsp;нужно нажать правой кнопкой на файле с тестом и выбрать **'Run As -> JUnit Test'**

Для работы с JUnit необходимо добавить junit в качестве библиотеки. Это можно сделать воспользовавшись подсказкой Eclipse у строки импорта.

Либо это можно сделать вручную через меню **Project - Properties - Java Build Path - Libraries - Add External JARs**, выбрать файл <ПутьДоEclipse>*** \plugins\org.junit*\junit.jar ***
# Как правильно писать тесты #
Вот самые простые правила, которыми нужно руководствоваться:
<ul>
	<li>&nbsp;Лучше путь тестов будет сильно больше, чем немного меньше.</li>
	<li>&nbsp;Тесты должны покрывать все возможные крайние случаи.</li>
	<li>&nbsp;При выполнении тестов, 100% тестируемого кода должно выполниться.</li>
	<li>&nbsp;Тесты должны быть упорядочены так, чтобы более простые для понимания тесты шли первыми.</li>
	<li>&nbsp;Тесты должны быть устроены таким образом, чтобы добавлять новые тестовые случаи было максимально просто.</li>
</ul>
Но простыми правилами всё не ограничивается &mdash; есть множество подходов к тестированию программного обеспечения. Ниже будут приведены некоторые из них с очень кратким и поверхностным описанием.

Важный вопрос при разработке модульных тестов: когда остановиться? в каком момент можно сказать, что код протестирован полностью? Однозначеного ответа на этот вопрос нет, но есть некоторое количество методик, которые позволяют определить, что комплект тестов является неполным.
## Покрытие операторов ##
Если при прогоне всех тестов остались операторы, которые не выполнились ни разу &mdash; набор тестов не полный.

Существуют специальные системы, которые позволяют измерять сколько раз была выполнена каждая строка кода в процессе работы тестов.
## Анализ условий и граничных значений ##
Если в тестируемой программе есть развилки (if / switch / ...), то в процессе выполнения тестов каждое такое условие должно хотя бы один раз сработать и хотя бы один раз не сработать.

Более того, если условие &mdash; это сложное сравнение числа с некоторым пороговым значением, то должны быть тесты проверяющие правильное срабатывание условия в пограничных ситуациях.
Для примера рассмотрим следующий код:
{% highlight java %}
d = b * b + 4 a * b;
if (b == 0) return 1;
else if (b < 0) return 0;
return 2;{% endhighlight %}
&nbsp;

Для проверки граничных значений, должны быть следующие тестовые случаи:
<ul>
	<li>случай, в котором d == 0;</li>
	<li>случай, в котором d &mdash; очень маленькое положительное число;</li>
	<li>случай, в котором d &mdash; очень маленькое по модулю отрицательное число.</li>
</ul>
Если в программе есть циклы, то до в процессе выполнения тестов, каждый цикл должен хотя бы раз выполнить минимальное количество итераций, и хотя бы раз выполнить несколько итераций.

Для примера рассмотрим следующий код:
{% highlight java %}String message = "My friends: ";
for (int i=0; i<friendsCount; i++)
message += friend[i] + " ";
return message;{% endhighlight %}
Для полноценной проверки, нужны два тестовых случая:
<ul>
	<li>когда есть несколько друзей;</li>
	<li>когда друзей нет.</li>
</ul>
## Анализ путей выполнения ##
Этот метод ещё более требователен к полноте тестов. Согласно ему, все возможные пути через тестируемую часть кода должны быть хотя бы раз выполнены в процессе тестирования. Рассмотрим пример кода &mdash; попиксельное рисование линии алгоритмом Брезенхама:
{% highlight java %}void drawLine(int x1, int y1, int x2, int y2)
{
int slope;
int dx, dy, incE, incNE, d, x, y;
if (x1 > x2){
drawLine(x2, y2, x1, y1);
return;
}
dx = x2 - x1;
dy = y2 - y1;
if (dy < 0) {
slope = -1;
dy = -dy;
}
else
slope = 1;
incE = 2 * dy;
incNE = 2 * dy - 2 * dx;
d = 2 * dy - dx;
y = y1;
for (x = x1; x <= x2; x++) {
putPixel(x, y);
if (d <= 0)
d += incE;
else {
d += incNE;
y += slope;
}
}
}{% endhighlight %}
Для этого алгоритма согласно методу анализа путей выполнения должны быть добавлены следующие тестовые случаи:
<ul>
	<li>x1 > x2 && y1 > y2</li>
	<li>x1 > x2 && y1 < y2</li>
	<li>x1 > x2 && y1 == y2</li>
	<li>x1 < x2 && y1 > y2</li>
	<li>x1 < x2 && y1 < y2</li>
	<li>x1 < x2 && y1 == y2</li>
	<li>x1 == x2 && y1 > y2</li>
	<li>x1 == x2 && y1 < y2</li>
	<li>x1 == x2 && y1 == y2</li>
</ul>
# Резюме #
<ul>
	<li>&nbsp;Писать программы нужно путём декомпозиции её на независимые модули. Каждый модуль с нетривиальным поведением должен быть протестирован модульным тестом.</li>
	<li>Для поддержки концепции модульных тестов есть большое количество библиотек, почти для любого языка программирования. Это даёт возможность лишний раз не изобретать велосипед.</li>
	<li>При создании модульного теста лучше лучше переборщить с тестовыми случаями, чем недоборщить. Для того, чтобы понять, каких тестов ещё не хватает, можно использовать различные методики анализа кода: анализ покрытия операторов тестами, анализ условий, анализ граничных значений, анализ путей исполнения.</li>
</ul>
# Ссылки #
<ul>
	<li>http://ru.wikipedia.org/wiki/Юнит-тестирование</li>
	<li>http://en.wikipedia.org/wiki/JUnit</li>
	<li>http://wiki.agiledev.ru/doku.php?id=tdd:testing_advantages &mdash; Test Driven Development</li>
	<li>http://www.citforum.ru/SE/testing/mod_test/ &mdash; модульное тестирование</li>
	<li>http://www.google.com/search?q=Модульное+тестирование</li>
	<li>http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks &mdash; список систем модульного тестирования</li>
	<li>[http://www.ozon.ru/context/detail/id/1501671/ Кент Бек, Экстремальное программирование: разработка через тестирование]</li>
</ul>
