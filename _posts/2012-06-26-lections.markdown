---
layout: post
status: publish
published: true
title: Конспект АБД
author: M_Messiah
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://brainstorage.me/M_Messiah
excerpt: "Весь конспект лекций по АБД"
date: 2012-06-26 23:45:30.000000000 +06:00
categories: SQL
tags: []
comments: []
---
# Весь конспект. #

# Отношение #
Отношение &ndash; подмножество декартова произведения. При этом множества называются доменами.

Отношения удобно представлять в виде таблиц. Строки таблицы соответствуют кортежам. Каждая строка представляет какую-либо сущность.

Внутри каждого отношения атрибуты должны быть разными. А внутри объекта могут и повторяться.

Атрибут, идентифицирующий кортеж &ndash; ключ. Внешний ключ &ndash; значение атрибута, по которому удается восстановить связь с родительской таблицей, при условии, что значения в родительской таблице и дочерней &ndash; совпадают.

В реляционной БД отсутствует понятие группового отношения. Ключ просто дублируется для каждой сущности.
## Свойства отношений: ##
<ul>
	<li>Отсутствие дублированных записей. Решается наличием ключа.</li>
	<li>Отсутствие упорядоченности кортежей. (Порядок не влияет на отношение)</li>
	<li>Отсутствует порядок атрибутов (столбцов) (Т.е. порядок не влияет)</li>
	<li>Значение атрибута неделимо (атомарно)</li>
</ul>
Функциональной зависимостью называется выражение вида: &laquo;Если 2 кортежа согласуются по атрибутам , то также согласуются и по еще одному атрибуту.&raquo;

Формально: А1,А2,А3, .. Аn -> B. (Функционально определяет)

Говорят, что множество атрибутов А1,А2, .. Аn - ключ отношения, если
<ul>
	<li>Функционально определяет все остальные атрибуты</li>
	<li>Наименьшее по включению</li>
</ul>
Суперключ &ndash; множество всех атрибутов, содержащих ключ.

Функциональная зависимость A1,A2,..,An->B1,.. Bn называется
<ul>
	<li>Тривиальной, если B подмножество А</li>
	<li>Нетривиальной &ndash; если частично пересекаются</li>
	<li>Полностью нетривиальной, если не пересекаются</li>
</ul>
Пусть А={A1,&hellip;An} &ndash; множество атрибутов, S &ndash; множество функц. Зависимостей.

Замыкание &ndash; множество атрибутов, что всякое отношение, удовлетворяющее S, что A1,&hellip;An->B следует из S.

Обозначается {A1,&hellip;An}+

Функц. зависимости транзитивны.

{A1, An }+ Замыкание &ndash; это множество всех атрибутов  А1, &hellip; Аn суперключ этого отношения
## Аномалии в схеме реляционной базы: ##
<ul>
	<li>Избыточность (несколько раз повторяется инфа)</li>
	<li>Update аномалия &ndash; необходимость обнолять инфу в нескольких кортежах.</li>
	<li>Delete аномалия &ndash; удаление части может повлиять на другую инфу.</li>
</ul>
Для устранения аномалий используют правило декомпозиции отношений. (процесс разбиения исходного отношения на два и более).

Существует Нормальная форма Бойса-Кода (BCNF)

Отношение находится в BCNF когда не существует нетривиальной функц.зависимости, такой, что атрибуты &ndash; суперключ.
<ol>
	<li>Отношение в первой нормальной форме, если все атрибуты атомарны.</li>
	<li>Во второй, если он в первой, и каждый неключевой атрибут функц. зависит от ключа, но не зависит ни от какого подмножества ключа.</li>
	<li>В третьей &ndash; если он во второй, и не ключевой атрибут зависит нетранзитивно от ключа.</li>
	<li>В BCNF, если в третьей, отсутствуют зависимости атрибутов первичного ключа от неключевых атрибутов.</li>
</ol>
# Физическая модель #
<ul>
	<li>Физические аспекты хранения таблиц в определенных файлах.</li>
	<li>Создание индексов, оптимизирующий скорость выполнения данных.</li>
	<li>Выполнение различных действий над данными при определенных событиях.</li>
</ul>
## Целостность данных: ##
<ul>
	<li>Целостность сущностей (для каждого значения должен быть соответствующий ключ в родительском значении)</li>
	<li>Целостность ссылок.</li>
</ul>
Реляционное исчисление: алгебра и логика.

Основные операции: Добавить, Удалить, Изменить.
## Операции обработки отношений: ##
<ul>
	<li>Проекция (вертикальное подмножество, без дубликатов)</li>
	<li>Выборка (горизонтальное подмножество)</li>
	<li>Пересечение (отношений)</li>
	<li>Разность</li>
	<li>Соединение</li>
</ul>
# История #
1975 &ndash; Основание Microsoft

1977 &ndash; Software Development&hellip; (ныне Oracle)

1986 &ndash; Появление технологии &laquo;клиент-сервер&raquo;

1988 &ndash; Первая версия Microsoft SQL Server

И.т.п
# Архитектура сервера #
Sql Server использует для хранения баз данных набор файлов ОС
<ul>
	<li>Первичные файлы .mdf</li>
	<li>Вторичные файлы .ndf</li>
	<li>Логи .ldf</li>
</ul>
При создании БД все её прошлые файлы зануляются.
## Таблицы ##
&ndash; наборы страниц с заголовком (имя, связки, указание на другие страницы таблицы). В конце &ndash; таблица смещений строк. Всё остальное - поля таблицы.
## Авторизация: ##
## Windows и SQL ##
Встроенный пользователь sa &ndash; System Administrator.
## Клиенты: ##
SQL Server Management Studio
## Команды: ##
{% highlight sql %}Create Table table_name
( {
 |column_name AS computed_column_expression
| ::=[CONSTRAINT constraint_name}
| [{PRIMARY KEY &hellip;&hellip;&hellip;&hellip;..{% endhighlight %}
## ЯЗЫК SQL: ##
Выбор
{% highlight sql %}SELECT FROM
WHERE{% endhighlight %}
&nbsp;
### Пример: ###
{% highlight sql %}SELECT * FROM USP WHERE ID=38725{% endhighlight %}
LIKE &ndash; символьные поля CHAR NCHAR

//Я не понимаю, куда она торопится. Капец. Какой смысл так рассказывать?

//Гомоморфный образ группы, в честь победы коммунизма, изоморфен фактор группе по ядру гомоморфизма!
### Обновление записей: ###
{% highlight sql %}UPDATE { имя таблицы} SET {что модифицировать}
{{[FROM набор таблиц источников][WHERE &hellip; .. }}
--E.g.
Update authors SET authors.au_fname = &lsquo;Annie&rsquo; WHERE au_fname = &lsquo;Anne&rsquo;{% endhighlight %}
### Удаление ###
{% highlight sql %}DELETE [FROM] &hellip; [WHERE &hellip; ]{% endhighlight %}
E.g. DELETE authors &ndash; очищает все строки
{% highlight sql %}DELETE FROM authors WHERE au_lname =&rsquo;McBadden&rsquo;{% endhighlight %}
Удалить всю таблицу &ndash; TRUNCATE
{% highlight sql %}SELECT * FROM authors ORDER BY au_lname ASC, au_fname ASC{% endhighlight %}
(сортировка по имени и фамилии по возрастанию)

{% highlight sql %}SELECT 1 &lsquo;qq&rsquo; &ndash; {% endhighlight %} вывод на экран
### Соединения: ###
INNER JOIN - выбор и объединение строк из 2-х таблиц основываясь на условии совпадения значений некоторых полей строк

LEFT JOIN или LEFT OUTER JOIN &ndash; в результате &ndash; все строки левой таблицы, даже если в правой нет строк, содержащих значения, удовлетворяющие условию join`a

RIGHT JOIN, RIGHT OUTER JOIN- то же, только наоборот.

FULL JOIN, FULL OUTER JOIN &ndash; соединит все строки из обеих таблиц

CROSS JOIN &ndash; сочетание всего
### Функции: ###
CAST (expression AS data_type) преобразование

CONVERT ( data_type, expression, [style]) &ndash; преобразование

GETDATE() &ndash; текущая дата

DATEADD(datepart, number, date) &ndash; добавляет дату

DATEDIFF(datepart,startdate,enddate) &ndash; разница в единицах datepart

### Создание временных таблиц: ###
{% highlight sql %}#nametable {% endhighlight %}&ndash; локальная таблица временная. Исчезает с прекращением сеанса

{% highlight sql %}##nametable {% endhighlight %}&ndash; глобальная временная таблица.

@ - переменные.
{% highlight sql %}Declare @sql_stmnt varchar(50)
Set @sql_stmnt = &lsquo;select * from people&rsquo;
Exec(@sql_stmnt){% endhighlight %}
### Условия: ###
{% highlight sql %}IF логика { } [ELSE { } ]{% endhighlight %}
{% highlight sql %}WHILE bool { } [break] { } [continue]{% endhighlight %}
Курсор &ndash; сформированный пользователем табличный объект, откуда можно читать построчно.

DECLARE cursor_name CURSOR

[LOCAL|GLOBAL] [FORWARD_ONLY|SCROLL] [STATIC|DYNAMIC|FAST_FORWARD]

..

FOR select_statement

.

OPEN - открыть курсор

Движение по курсору командой FETCH

DECLARE CURSOR STIPCUR FOR sname, stip&hellip;

EXEC SQL CURSOR STIPCUR
### Представления ###
Представление VIEW &ndash; это именованная виртуальная таблица, содержание которой выбирается из других таблиц с помощью запросов.

При изменении значений в таблицах автоматически меняются значения преставления.

Наличие имени у такой таблицы позволяет пользователю выполнять операции с базовыми таблицами.

Базовые таблицы &ndash; таблицы которые содержат данные и постоянно находятся на устройствах хранения информации. Представления по сравнению с ними являются более гибкими средствами. Когда СУБД отыскивает в команде ссылку на представление.

СУБД имен 2 возможности реализации представления:
<ul>
	<li>&nbsp;Если определение представления простое, то система формирует каждую запись по мере необходимости</li>
	<li>&nbsp;Если представление сложное, СУБД сначала выполняет материализацию выполнения, затем система выполняет пользовательские команды.</li>
</ul>
CREATE VIEWAS select &hellip; from &hellip; where &hellip;

Нельзя UNION объеденения. Нельзя ORDER BY.

Удаление представлений: DROP VIEW

Не должно использовать группировки, условия. Для вставки - любые поля базовой таблицы.
## Транзакция ##
&ndash; совокупность действий пользователя. Модуль для выполнения.
<ul>
	<li>Atomicity &ndash; атомарность. Либо все изменения в транзакции, либо ни одного.</li>
	<li>Consistency(постоянство) &ndash; после завершения не должна быть нарушена целостность данных.</li>
	<li>Isolation(изолированность) Изменения изолируются от других транзакций.</li>
	<li>Durability(устойчивость) изменения в любом случае, даже если был сбой.</li>
</ul>
### Запуск транзакции: ###
<ul>
	<li>Explicit &ndash; явная. BEGIN TRANSACTION.</li>
	<li>Autocommit &ndash; автоматически после блока команд.</li>
	<li>Implicit &ndash; неявная. SET IMPLICIT TRANSACTION ON/OFF</li>
</ul>
### Завершение транзакции: ###
Конструкция COMMIT

Если ошибка &ndash; ROLLBACK возврат к точке отката.

Create functionreturns[as .. ] begin &hellip; return .. end

Create fuction &hellip; returns table begin &hellip; return .. end

Для того, чтобы определить в какой нормальной форме БД &mdash; нужно оценить нормальность форм каждой таблицы, а потом взять наименьшую.

1 нормальная форма &mdash; в каждой ячейке &mdash; неделимое значение.

2 нормальная форма &mdash; нет функциональных зависимостей.

3 нормальная форма &mdash; нет транзитивных зависимостей.

Промежуток &ndash; после Group BY - написать

Having нужное between ### and ###
### Триггер ###
Триггер &ndash; процедуры, хранимые в БД. Вызываются автоматически.

Пример
{% highlight sql %}Create table my_table( a int NULL, b int NULL)
Go
ALTER TRIGGER my_trig ON my_table{% endhighlight %}
Функции пользователя: скалярные и возвращающие таблицу.
{% highlight sql %}Create function abcd (@trener varchar (50))
Returns table
As
Return (select treners.fam, vidsporta.namesp
from treners inner join vidsporta on treners.vidsp=vidsporta.vidsp
where treners.fam=@trener){% endhighlight %}
### Вызов функции: ###
Select * from abcd(&lsquo;Филин&rsquo;)
### Фантомы ###
<ul>
	<li>Проблема &ldquo;грязной записи&rdquo;</li>
	<li>Проблема &ldquo;грязного чтения&rdquo; - транзакция пытается читать временные данные, с которыми работает другая параллельная транзакция.</li>
	<li>Проблема повторного чтения &ndash; из-за параллельных потоков повторное чтение может привести к другому результату.</li>
	<li>Проблема фантомов &mdash; изменение выборки данных другой параллельной транзакцией.</li>
</ul>
Для реализации разрешения этих проблем необходимо изолировать транзакции друг от друга.

Для уровней изоляции используются блокировки &mdash; LOCKs.
### Уровни: ###
1. No trashing of data. (Запрещение загрязнения данных) Запрет на параллельное изменение данных.

2. No read &mdash; Запрет параллельного чтения данных.

3. No phantom. Ни изменять, ни вставлять новые данные параллельно.

SERIALIZABLE &mdash; никаких проблем, но очень непроизводительно.
### Сущности блокировки: ###
<ul>
	<li>БД</li>
	<li>Таблица</li>
	<li>Экстент &mdash; страницы</li>
	<li>Страница</li>
	<li>Строка</li>
	<li>Диапазон индекса.</li>
</ul>
### Простые блокировки: ###
<ul>
	<li>Разделяемые блокировки (Shared)</li>
	<li>Монопольные (Exclusive) (X)</li>
	<li>Update &mdash; среднее между S и X</li>
</ul>
### Блокировки намерений: ###
Всегда на таблицу, никогда на строчку. Очень суровы.
<ul>
	<li>Разделяемая блокировка намерений IS</li>
	<li>Монопольная блокировка намерений IX</li>
</ul>
## Репликация. Дублирование. Восстановление ##
Репликация &ndash; это процесс, который производит обмен между базами данных, находящихся на одном и том же сервере или на других серверах

Репликация использует метафоры:

Publisher &ndash; сервер или группа баз данных, которая отсылает свои данные да другой сервер или в другую базу данных. Содержит публикацию или группы публикаций. Публикация &ndash; совокупность одной или более статей, которые посылаются серверу подписчику или бд. Статья &ndash; основной модуль репликации и это может быть таблица или подмножество таблицы.

Distributor-сервер, который управляет потоком данных через систему репликации. Этот сервер содержит специализированную БД: Distribution database

Subscriber- сервер или БД, которая получает данные от другого сервера иди другой БД
### Виды подписок: ###
<ul>
	<li>Push subscription</li>
	<li>Pull subcription</li>
	<li>Distribution db &ndash; это системная БД, которая хранится на дистрибуторе и не содержит никаких пользовательских таблиц.</li>
</ul>
### ТОПОЛОГИЯ РЕПЛИКАЦИИ ###

- Центральный publisher &ndash; один сервер исполняет роли publisher и distributor
- центральный Subscriber &ndash; обычная топология. Несколько серверов или БД копируют свои данные в центральный сервер в одну или несколько БД.
- Центральный publisher с отдаленным distributor

### Репликации: ###

Snapshot - полный снимок базы.

+ Транзакционные &ndash; сохраняет снимок базы как сценарий insert,update,delete&nbsp;(используются когда часто изменяются, или нет смысла поддерживать всё-всё)
+ Merge &ndash; синхронизация баз

### Утилиты: ###

1. Snapshot Agent
2. LOG READER AGENT &ndash; логи.
3. Distribution agent
4. Merge Agent

### GUI ###
Пишется с помощью API на JavaScript, с помощью ASP.

### Виды соединений: ###

+ ODBC &ndash; Open DB Connectivity
+ OLE DB &ndash; буфер обмена например
+ ActiveX Data Objects (ADO)
+ Borland DB Engine (BDE)
+ ADO.NET
