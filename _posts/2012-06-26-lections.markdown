---
layout: post
status: publish
published: true
title: Конспект АБД
author: ––=Messiλh=––
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://m.muzafarov.vk.com
excerpt: "<h1>Весь конспект.<&#47;h1>\r\n"
wordpress_id: 107
wordpress_url: http://messiah.ks8.ru/wordpress/?p=107
date: 2012-06-26 23:45:30.000000000 +06:00
categories:
- SQL
tags: []
comments: []
---
<h1>Весь конспект.<&#47;h1>
<a id="more"></a><a id="more-107"></a>
<h1><&#47;h1>
<h1>Отношение<&#47;h1>
Отношение &ndash; подмножество декартова произведения. При этом множества называются доменами.

Отношения удобно представлять в виде таблиц. Строки таблицы соответствуют кортежам. Каждая строка представляет какую-либо сущность.

Внутри каждого отношения атрибуты должны быть разными. А внутри объекта могут и повторяться.

Атрибут, идентифицирующий кортеж &ndash; ключ. Внешний ключ &ndash; значение атрибута, по которому удается восстановить связь с родительской таблицей, при условии, что значения в родительской таблице и дочерней &ndash; совпадают.

В реляционной БД отсутствует понятие группового отношения. Ключ просто дублируется для каждой сущности.
<h2>Свойства отношений:<&#47;h2>
<ul>
	<li>Отсутствие дублированных записей. Решается наличием ключа.<&#47;li>
	<li>Отсутствие упорядоченности кортежей. (Порядок не влияет на отношение)<&#47;li>
	<li>Отсутствует порядок атрибутов (столбцов) (Т.е. порядок не влияет)<&#47;li>
	<li>Значение атрибута неделимо (атомарно)<&#47;li>
<&#47;ul>
Функциональной зависимостью называется выражение вида: &laquo;Если 2 кортежа согласуются по атрибутам , то также согласуются и по еще одному атрибуту.&raquo;

Формально: А1,А2,А3, .. Аn -> B. (Функционально определяет)

Говорят, что множество атрибутов А1,А2, .. Аn - ключ отношения, если
<ul>
	<li>Функционально определяет все остальные атрибуты<&#47;li>
	<li>Наименьшее по включению<&#47;li>
<&#47;ul>
Суперключ &ndash; множество всех атрибутов, содержащих ключ.

Функциональная зависимость A1,A2,..,An->B1,.. Bn называется
<ul>
	<li>Тривиальной, если B подмножество А<&#47;li>
	<li>Нетривиальной &ndash; если частично пересекаются<&#47;li>
	<li>Полностью нетривиальной, если не пересекаются<&#47;li>
<&#47;ul>
Пусть А={A1,&hellip;An} &ndash; множество атрибутов, S &ndash; множество функц. Зависимостей.

Замыкание &ndash; множество атрибутов, что всякое отношение, удовлетворяющее S, что A1,&hellip;An->B следует из S.

Обозначается {A1,&hellip;An}+

Функц. зависимости транзитивны.

{A1, An }+ Замыкание &ndash; это множество всех атрибутов  А1, &hellip; Аn суперключ этого отношения
<h2>Аномалии в схеме реляционной базы:<&#47;h2>
<ul>
	<li>Избыточность (несколько раз повторяется инфа)<&#47;li>
	<li>Update аномалия &ndash; необходимость обнолять инфу в нескольких кортежах.<&#47;li>
	<li>Delete аномалия &ndash; удаление части может повлиять на другую инфу.<&#47;li>
<&#47;ul>
Для устранения аномалий используют правило декомпозиции отношений. (процесс разбиения исходного отношения на два и более).

Существует Нормальная форма Бойса-Кода (BCNF)

Отношение находится в BCNF когда не существует нетривиальной функц.зависимости, такой, что атрибуты &ndash; суперключ.
<ol>
	<li>Отношение в первой нормальной форме, если все атрибуты атомарны.<&#47;li>
	<li>Во второй, если он в первой, и каждый неключевой атрибут функц. зависит от ключа, но не зависит ни от какого подмножества ключа.<&#47;li>
	<li>В третьей &ndash; если он во второй, и не ключевой атрибут зависит нетранзитивно от ключа.<&#47;li>
	<li>В BCNF, если в третьей, отсутствуют зависимости атрибутов первичного ключа от неключевых атрибутов.<&#47;li>
<&#47;ol>
<h1>Физическая модель<&#47;h1>
<ul>
	<li>Физические аспекты хранения таблиц в определенных файлах.<&#47;li>
	<li>Создание индексов, оптимизирующий скорость выполнения данных.<&#47;li>
	<li>Выполнение различных действий над данными при определенных событиях.<&#47;li>
<&#47;ul>
<h2>Целостность данных:<&#47;h2>
<ul>
	<li>Целостность сущностей (для каждого значения должен быть соответствующий ключ в родительском значении)<&#47;li>
	<li>Целостность ссылок.<&#47;li>
<&#47;ul>
Реляционное исчисление: алгебра и логика.

Основные операции: Добавить, Удалить, Изменить.
<h2>Операции обработки отношений:<&#47;h2>
<ul>
	<li>Проекция (вертикальное подмножество, без дубликатов)<&#47;li>
	<li>Выборка (горизонтальное подмножество)<&#47;li>
	<li>Пересечение (отношений)<&#47;li>
	<li>Разность<&#47;li>
	<li>Соединение<&#47;li>
<&#47;ul>
<h1>История<&#47;h1>
1975 &ndash; Основание Microsoft

1977 &ndash; Software Development&hellip; (ныне Oracle)

1986 &ndash; Появление технологии &laquo;клиент-сервер&raquo;

1988 &ndash; Первая версия Microsoft SQL Server

И.т.п
<h1>Архитектура сервера<&#47;h1>
Sql Server использует для хранения баз данных набор файлов ОС
<ul>
	<li>Первичные файлы .mdf<&#47;li>
	<li>Вторичные файлы .ndf<&#47;li>
	<li>Логи .ldf<&#47;li>
<&#47;ul>
При создании БД все её прошлые файлы зануляются.
<h2>Таблицы<&#47;h2>
&ndash; наборы страниц с заголовком (имя, связки, указание на другие страницы таблицы). В конце &ndash; таблица смещений строк. Всё остальное - поля таблицы.
<h2>Авторизация:<&#47;h2>
<h2>Windows и SQL<&#47;h2>
Встроенный пользователь sa &ndash; System Administrator.
<h2>Клиенты:<&#47;h2>
SQL Server Management Studio
<h2>Команды:<&#47;h2>
<pre class="brush: sql; gutter: false">Create Table table_name
( {
 |column_name AS computed_column_expression
| ::=[CONSTRAINT constraint_name}
| [{PRIMARY KEY &hellip;&hellip;&hellip;&hellip;..<&#47;pre>
<h2>ЯЗЫК SQL:<&#47;h2>
Выбор
<pre class="brush: sql; gutter: false">SELECT FROM
WHERE<&#47;pre>
&nbsp;
<h3>Пример:<&#47;h3>
<pre class="brush: sql; gutter: false">SELECT * FROM USP WHERE ID=38725<&#47;pre>
LIKE &ndash; символьные поля CHAR NCHAR

&#47;&#47;Я не понимаю, куда она торопится. Капец. Какой смысл так рассказывать?

&#47;&#47;Гомоморфный образ группы, в честь победы коммунизма, изоморфен фактор группе по ядру гомоморфизма!
<h3>Обновление записей:<&#47;h3>
<pre class="brush: sql; gutter: true">UPDATE { имя таблицы} SET {что модифицировать}
{{[FROM набор таблиц источников][WHERE &hellip; .. }}
--E.g.
Update authors SET authors.au_fname = &lsquo;Annie&rsquo; WHERE au_fname = &lsquo;Anne&rsquo;<&#47;pre>
<h3>Удаление<&#47;h3>
<pre class="brush: sql; gutter: false">DELETE [FROM] &hellip; [WHERE &hellip; ]<&#47;pre>
E.g. DELETE authors &ndash; очищает все строки
<pre class="brush: sql; gutter: false">DELETE FROM authors WHERE au_lname =&rsquo;McBadden&rsquo;<&#47;pre>
Удалить всю таблицу &ndash; TRUNCATE
<pre class="brush: sql; gutter: false">SELECT * FROM authors ORDER BY au_lname ASC, au_fname ASC<&#47;pre>
(сортировка по имени и фамилии по возрастанию)

SELECT 1 &lsquo;qq&rsquo; &ndash; вывод на экран
<h3>Соединения:<&#47;h3>
INNER JOIN - выбор и объединение строк из 2-х таблиц основываясь на условии совпадения значений некоторых полей строк

LEFT JOIN или LEFT OUTER JOIN &ndash; в результате &ndash; все строки левой таблицы, даже если в правой нет строк, содержащих значения, удовлетворяющие условию join`a

RIGHT JOIN, RIGHT OUTER JOIN- то же, только наоборот.

FULL JOIN, FULL OUTER JOIN &ndash; соединит все строки из обеих таблиц

CROSS JOIN &ndash; сочетание всего
<h3>Функции:<&#47;h3>
CAST (expression AS data_type) преобразование

CONVERT ( data_type, expression, [style]) &ndash; преобразование

GETDATE() &ndash; текущая дата

DATEADD(datepart, number, date) &ndash; добавляет дату

DATEDIFF(datepart,startdate,enddate) &ndash; разница в единицах datepart
<h3>Сценарии &ndash; скрипты:<&#47;h3>
<h3>Создание временных таблиц:<&#47;h3>
#nametable &ndash; локальная таблица временная. Исчезает с прекращением сеанса

##nametable &ndash; глобальная временная таблица.

@ - переменные.
<pre class="brush: sql; gutter: true">Declare @sql_stmnt varchar(50)
Set @sql_stmnt = &lsquo;select * from people&rsquo;
Exec(@sql_stmnt)<&#47;pre>
<h3>Условия:<&#47;h3>
<pre class="brush: sql; gutter: false">IF логика { } [ELSE { } ]<&#47;pre>
<pre class="brush: sql; gutter: false">WHILE bool { } [break] { } [continue]<&#47;pre>
Курсор &ndash; сформированный пользователем табличный объект, откуда можно читать построчно.

DECLARE cursor_name CURSOR

[LOCAL|GLOBAL] [FORWARD_ONLY|SCROLL] [STATIC|DYNAMIC|FAST_FORWARD]

..

FOR select_statement

.

OPEN - открыть курсор

Движение по курсору командой FETCH

DECLARE CURSOR STIPCUR FOR sname, stip&hellip;

EXEC SQL CURSOR STIPCUR
<h3>Представления<&#47;h3>
Представление VIEW &ndash; это именованная виртуальная таблица, содержание которой выбирается из других таблиц с помощью запросов.

При изменении значений в таблицах автоматически меняются значения преставления.

Наличие имени у такой таблицы позволяет пользователю выполнять операции с базовыми таблицами.

Базовые таблицы &ndash; таблицы которые содержат данные и постоянно находятся на устройствах хранения информации. Представления по сравнению с ними являются более гибкими средствами. Когда СУБД отыскивает в команде ссылку на представление.

СУБД имен 2 возможности реализации представления:
<ul>
	<li>&nbsp;Если определение представления простое, то система формирует каждую запись по мере необходимости<&#47;li>
	<li>&nbsp;Если представление сложное, СУБД сначала выполняет материализацию выполнения, затем система выполняет пользовательские команды.<&#47;li>
<&#47;ul>
CREATE VIEWAS select &hellip; from &hellip; where &hellip;

Нельзя UNION объеденения. Нельзя ORDER BY.

Удаление представлений: DROP VIEW

Не должно использовать группировки, условия. Для вставки - любые поля базовой таблицы.
<h2>Транзакция<&#47;h2>
&ndash; совокупность действий пользователя. Модуль для выполнения.
<ul>
	<li>Atomicity &ndash; атомарность. Либо все изменения в транзакции, либо ни одного.<&#47;li>
	<li>Consistency(постоянство) &ndash; после завершения не должна быть нарушена целостность данных.<&#47;li>
	<li>Isolation(изолированность) Изменения изолируются от других транзакций.<&#47;li>
	<li>Durability(устойчивость) изменения в любом случае, даже если был сбой.<&#47;li>
<&#47;ul>
<h3>Запуск транзакции:<&#47;h3>
<ul>
	<li>Explicit &ndash; явная. BEGIN TRANSACTION.<&#47;li>
	<li>Autocommit &ndash; автоматически после блока команд.<&#47;li>
	<li>Implicit &ndash; неявная. SET IMPLICIT TRANSACTION ON&#47;OFF<&#47;li>
<&#47;ul>
<h3>Завершение транзакции:<&#47;h3>
Конструкция COMMIT

Если ошибка &ndash; ROLLBACK возврат к точке отката.

Create functionreturns[as .. ] begin &hellip; return .. end

Create fuction &hellip; returns table begin &hellip; return .. end

Для того, чтобы определить в какой нормальной форме БД &mdash; нужно оценить нормальность форм каждой таблицы, а потом взять наименьшую.

1 нормальная форма &mdash; в каждой ячейке &mdash; неделимое значение.

2 нормальная форма &mdash; нет функциональных зависимостей.

3 нормальная форма &mdash; нет транзитивных зависимостей.

Промежуток &ndash; после Group BY - написать

Having нужное between ### and ###
<h3>Триггер<&#47;h3>
Триггер &ndash; процедуры, хранимые в БД. Вызываются автоматически.

Пример
<pre class="brush: sql; gutter: false">Create table my_table( a int NULL, b int NULL)
Go
ALTER TRIGGER my_trig ON my_table<&#47;pre>
Функции пользователя: скалярные и возвращающие таблицу.
<pre class="brush: sql; gutter: true">Create function abcd (@trener varchar (50))
Returns table
As
Return (select treners.fam, vidsporta.namesp
from treners inner join vidsporta on treners.vidsp=vidsporta.vidsp
where treners.fam=@trener)<&#47;pre>
<h3>Вызов функции:<&#47;h3>
Select * from abcd(&lsquo;Филин&rsquo;)
<h3>Фантомы<&#47;h3>
<ul>
	<li>Проблема &ldquo;грязной записи&rdquo;<&#47;li>
	<li>Проблема &ldquo;грязного чтения&rdquo; - транзакция пытается читать временные данные, с которыми работает другая параллельная транзакция.<&#47;li>
	<li>Проблема повторного чтения &ndash; из-за параллельных потоков повторное чтение может привести к другому результату.<&#47;li>
	<li>Проблема фантомов &mdash; изменение выборки данных другой параллельной транзакцией.<&#47;li>
<&#47;ul>
Для реализации разрешения этих проблем необходимо изолировать транзакции друг от друга.

Для уровней изоляции используются блокировки &mdash; LOCKs.
<h3>Уровни:<&#47;h3>
1. No trashing of data. (Запрещение загрязнения данных) Запрет на параллельное изменение данных.

2. No read &mdash; Запрет параллельного чтения данных.

3. No phantom. Ни изменять, ни вставлять новые данные параллельно.

SERIALIZABLE &mdash; никаких проблем, но очень непроизводительно.
<h3>Сущности блокировки:<&#47;h3>
<ul>
	<li>БД<&#47;li>
	<li>Таблица<&#47;li>
	<li>Экстент &mdash; страницы<&#47;li>
	<li>Страница<&#47;li>
	<li>Строка<&#47;li>
	<li>Диапазон индекса.<&#47;li>
<&#47;ul>
<h3>Простые блокировки:<&#47;h3>
<ul>
	<li>Разделяемые блокировки (Shared)<&#47;li>
	<li>Монопольные (Exclusive) (X)<&#47;li>
	<li>Update &mdash; среднее между S и X<&#47;li>
<&#47;ul>
<h3>Блокировки намерений:<&#47;h3>
Всегда на таблицу, никогда на строчку. Очень суровы.
<ul>
	<li>Разделяемая блокировка намерений IS<&#47;li>
	<li>Монопольная блокировка намерений IX<&#47;li>
<&#47;ul>
<h2>Репликация. Дублирование. Восстановление<&#47;h2>
Репликация &ndash; это процесс, который производит обмен между базами данных, находящихся на одном и том же сервере или на других серверах

Репликация использует метафоры:

Publisher &ndash; сервер или группа баз данных, которая отсылает свои данные да другой сервер или в другую базу данных. Содержит публикацию или группы публикаций. Публикация &ndash; совокупность одной или более статей, которые посылаются серверу подписчику или бд. Статья &ndash; основной модуль репликации и это может быть таблица или подмножество таблицы.

Distributor-сервер, который управляет потоком данных через систему репликации. Этот сервер содержит специализированную БД: Distribution database

Subscriber- сервер или БД, которая получает данные от другого сервера иди другой БД
<h3>Виды подписок:<&#47;h3>
<ul>
	<li>Push subscription<&#47;li>
	<li>Pull subcription<&#47;li>
	<li>Distribution db &ndash; это системная БД, которая хранится на дистрибуторе и не содержит никаких пользовательских таблиц.<&#47;li>
<&#47;ul>
<h3>ТОПОЛОГИЯ РЕПЛИКАЦИИ<&#47;h3>
- Центральный publisher &ndash; один сервер исполняет роли publisher и distributor

- центральный Subscriber &ndash; обычная топология. Несколько серверов или БД копируют свои данные в центральный сервер в одну или несколько БД.

- Центральный publisher с отдаленным distributor -
<h3>Репликации:<&#47;h3>
Snapshot - полный снимок базы.
<ul>
	<li>Транзакционные &ndash; сохраняет снимок базы как сценарий insert,update,delete&nbsp;(используются когда часто изменяются, или нет смысла поддерживать всё-всё)<&#47;li>
	<li>Merge &ndash; синхронизация баз<&#47;li>
<&#47;ul>
<h3>Утилиты:<&#47;h3>
1. Snapshot Agent

2. LOG READER AGENT &ndash; логи.

3. Distribution agent

4. Merge Agent
<h3>GUI<&#47;h3>
Пишется с помощью API на JavaScript, с помощью ASP.
<h3>Виды соединений:<&#47;h3>
<ul>
	<li>ODBC &ndash; Open DB Connectivity<&#47;li>
	<li>OLE DB &ndash; буфер обмена например<&#47;li>
	<li>ActiveX Data Objects (ADO)<&#47;li>
	<li>Borland DB Engine (BDE)<&#47;li>
	<li>ADO.NET<&#47;li>
<&#47;ul>
