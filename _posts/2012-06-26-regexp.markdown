---
layout: post
status: publish
published: true
title: Регулярные выражения
author: M_Messiah
author_login: Messiah
author_email: m.muzafarov@gmail.com
author_url: http://brainstorage.me/M_Messiah
date: 2012-06-26 22:22:39.000000000 +06:00
categories: Perl
tags: []
comments: []
---
# Регулярные выражения Perl #

# Основной синтаксис #
<ul>
	<li>**[ ]** - символ, либо слайс, который может встретиться в поиске</li>
	<li>**{ <число> }** - сколько раз встречается</li>
	<li>**{<число>, <число>}**&nbsp;- промежуток сколько раз встречается. Если второго числа нет - то до бесконечности</li>
	<li>*** == {0, }**</li>
	<li>**+ == {1, }**</li>
	<li>**( )**&nbsp;- подстрока</li>
	<li>**.** - почти все символы, кроме перевода строки</li>
	<li>**\**&nbsp;- экранирование следующего символа</li>
	<li>**\d**&nbsp;- десятичные цифры == [0-9]</li>
	<li>**\D**&nbsp;- всё кроме цифр</li>
	<li>**\w**&nbsp;** == [A-z]**</li>
	<li>**\W**&nbsp;- всё кроме букв</li>
	<li>**|** - "ИЛИ"</li>
</ul>
''Клини выяснил, что стандартные (математические) регулярные выражения не решают проблему парности строк.''
<ul>
	<li>**(?{ })**&nbsp;- расширенное регулярное выражение</li>
	<li>**(? )** - группировка с захватом - ставит в соответствие переменным $1,$2.. те подстроки, которые удовлетворяют шаблону, заключённому в скобках</li>
	<li>**(?: )**&nbsp;- группировка без захвата</li>
</ul>

<!--more-->

**Параметры:**

**g** - глобальность (используется чтобы итератор в цикле двигался по строке дальше)

**i**&nbsp;- игнорирование регистра

**m&nbsp;**- игнорирование конца строки
**Match**
**~m/A(B*)/**&nbsp;- ищет подстроку, где идет А, потом произвольное количество символов B
{% highlight perl %}while ($r="CDABABB"=~m/(?:A(B*))/g) {print "$r $1 \n"; }{% endhighlight %}
<blockquote>Вывод:
1 B
1 BB</blockquote>
{% highlight perl %}while ($r="CDABABB"=~m/(A+|B+)/g) {print "$r $1 \n"; }{% endhighlight %}
<blockquote>Вывод:
1 A
1 B
1 A
1 BB</blockquote>
&nbsp;
{% highlight perl %}while ($r="CDABABB"=~m/(A*|B*)/g) {print " $r $1 \n"; }{% endhighlight %}
<blockquote>Вывод:
1
1
1 A
1
1 B
1 A
1
1 BB
1</blockquote>
<span style="font-style: normal;">
</span>
{% highlight perl %}@r="CDABABB"=~m/(A+|B+)/g; print " @r \n";{% endhighlight %}
<blockquote>Вывод:
A B A BB</blockquote>
**S**

**s/ / /;&nbsp;**Замена найденного тем, что справа.

**y**

****y/ / /;&nbsp;заменяет первое найденное на первое справа, второе - на второе. и.т.п.

**tr**

****tr/ / /;&nbsp;тоже замены

**Задачи**
## Задача о простейших совпадениях ##
Пусть есть файл Ф И О Ф И О

(6 колонок)

Нужно выдать всех многожёнцев.
{% highlight perl %}#!/usr/bin/perl -w
 $SRC_FN = "fiofio.txt";
open RFD, "<$SRC_FN" or die "Невозможно открыть файл $SRC_FN: $!";
while (<RFD>) {@s = split ' ',$_;
if (@s!=6)
{ print STDERR "Invalid line $.\n";
next;}
 $p1=join ' ',@s[0..2];
 $p2=join ' ',@s[3..5];
 $h{$p1}{$p2} = $h{$p2}{$p1}=1;
}
close RFD or die "Невозможно закрыть $SRC_FN:$!";
{local $\=$/;
print grep { (keys %{$h{$_}})>1 } keys %h;}{% endhighlight %}
## Поиск парных символов ##
Есть текст $_;
программа д.б. написана в / /x; (регвыр)
Должна выдавать если ровно два одинаковых символа, то выдавать количество всех пар.
Если пар нет - выдать 0
Проблема в том, что во-первых, символ произвольный,
во-вторых, строка ааа - работает, а это плохо.
Выражение /(a|b)$1/ то подставится то значение, которое было до него.
А чтобы получить то, что хотим, надо подставить \1 вместо $1 <a title="Doubles.pl" href="http://messiah.ks8.ru/wordpress/usu/perl/tasks/doubles">Doubles.pl</a>
## Нахождение нужного положения в строке ##
Константы можно писать с подчёркиванием.

&nbsp;
{% highlight perl %}$a= 1_000_000;
print "$a\n"; &nbsp;# всё таки выведет 1000000{% endhighlight %}
Поэтому хочется написать процедуру, которая будет вставлять подчёркивание&nbsp;<a title="InsUndrln.pl" href="http://messiah.ks8.ru/wordpress/usu/perl/tasks/insundrln">InsUndrln.pl</a>
## Поиск конкретных последовательностей символов ##
Для ознакомления с возможностями регулярных выражений, таких как:
<ul>
	<li>Не равно</li>
	<li>Равно</li>
	<li>Заглядывание вправо или влево от найденного,</li>
</ul>
Напишем программу для выделения IP адресов <a title="Ip_parser.pl" href="http://messiah.ks8.ru/wordpress/usu/perl/tasks/ip_parser">ip_parser.pl</a>
## Вложенные регулярки ##
**(??{ })** Блок кода рассматривается как регулярное выражение.
То есть мы можем написать здесь reverse $1 и работать с этим легко.
## Вложенные скобки ##
&nbsp;
{% highlight perl %}#!/usr/bin/perl -w
 $_="(())";
 $ptrn=qr/
 \(
 (?:
 (?>[^()]+)
 |
 (??{$ptrn})
 )*
 \)
 /x;
 $_=~/^(?>[^()]*)$ptrn(?>[^()]*)$/ or print "Error\n";{% endhighlight %}
## Произвольная функция ##
Есть текст на С. У какой то функции перед последней скобкой вставить какой-то параметр,
например: some_func(x,y,z) -> some_func(x,y,z ,NULL)
{% highlight perl %} #!/usr/bin/perl -w
 $_="some_func(x(y),z)";
 $ptrn=qr/
 \(
 (?:
 (?>[^()]+)
 |
 (??{$ptrn})
 )*
 \)
 /x;
$_=~s/(some_func\s*$ptrn)/$t=$1; substr($t,-1)=", NULL)"; $t/gxmse;
print;{% endhighlight %}
&nbsp;
